% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main_solver.R
\name{predict_spherical}
\alias{predict_spherical}
\title{Predict Spherical Responses for New Data}
\usage{
predict_spherical(fit, X_new)
}
\arguments{
\item{fit}{Fitted model object returned by \code{\link{spherical_sim_group}}}

\item{X_new}{New design matrix (n_new × p) for prediction}
}
\value{
Matrix of predicted responses (n_new × q) where each row is a unit
  vector on S^{q-1}. The i-th row is the predicted spherical response for
  the i-th row of X_new.
}
\description{
Generates predictions on the unit sphere for new covariate observations using
a fitted spherical single-index model with group lasso.
}
\details{
The prediction process follows these steps:
\enumerate{
  \item Compute single index for new data: z_new = X_new β̂
  \item Clip z values to valid knot range to avoid extrapolation
  \item Evaluate B-spline basis at z_new: B(z_new)
  \item Compute link function in R^{q-1}: U_new = B(z_new) Θ̂
  \item Map to unit sphere via inverse stereographic projection: Ŷ_new = π^{-1}(U_new)
}

\strong{Valid Prediction Range:}
Predictions are most reliable when z_new values fall within the range of
single index values observed in the training data. The function clips z values
to the knot range, but extrapolation beyond the training range may be unreliable.

\strong{Properties of Predictions:}
\itemize{
  \item Each predicted response lies exactly on the unit sphere: ||Ŷ_i|| = 1
  \item Predictions respect the single-index structure: similar X^T β values
        produce similar predictions
  \item Group sparsity in β̂ means predictions only depend on selected groups
}
}
\examples{
\dontrun{
# Generate training data
set.seed(123)
data <- generate_spherical_data(n = 200, p = 20, G = 4, seed = 123)

# Fit model
fit <- spherical_sim_group(
  X = data$X,
  Y = data$Y,
  group_idx = data$group_idx,
  lambda = 0.1,
  gamma = 0.1,
  n_knots = 5,
  verbose = FALSE
)

# Generate test data (same distribution)
test_data <- generate_spherical_data(n = 50, p = 20, G = 4, seed = 456)

# Make predictions
Y_pred <- predict_spherical(fit, test_data$X)

# Verify predictions are on unit sphere
all(abs(rowSums(Y_pred^2) - 1) < 1e-10)  # TRUE

# Compute prediction error
pred_error <- mean(rowSums((Y_pred - test_data$Y)^2))
cat("Test prediction error:", pred_error, "\n")

# Compare with training error
train_error <- mean(rowSums((fit$fitted - data$Y)^2))
cat("Train error:", train_error, "\n")
cat("Test error:", pred_error, "\n")

# Visualize predictions vs true responses (first 2 dimensions)
par(mfrow = c(1, 2))
plot(test_data$Y[,1], test_data$Y[,2], asp = 1,
     col = "blue", pch = 19, cex = 0.8,
     xlab = "Y[,1]", ylab = "Y[,2]",
     main = "True Responses")
plot(Y_pred[,1], Y_pred[,2], asp = 1,
     col = "red", pch = 19, cex = 0.8,
     xlab = "Ŷ[,1]", ylab = "Ŷ[,2]",
     main = "Predicted Responses")

# Prediction error vs single index
z_test <- as.vector(test_data$X \%*\% fit$beta)
errors <- rowSums((Y_pred - test_data$Y)^2)
plot(z_test, errors, pch = 19, cex = 0.8,
     xlab = "Single Index z", ylab = "Squared Error",
     main = "Prediction Error vs Single Index")

# Out-of-sample prediction on new design points
X_new <- matrix(rnorm(10 * 20), nrow = 10, ncol = 20)
Y_new_pred <- predict_spherical(fit, X_new)

# Check which groups are used for prediction
cat("Selected groups:", fit$selected_groups, "\n")
cat("Only these groups affect predictions\n")
}

}
\seealso{
\code{\link{spherical_sim_group}} for model fitting,
\code{\link{eval_link}} for evaluating the estimated link function,
\code{\link{inv_stereo}} for inverse stereographic projection
}
