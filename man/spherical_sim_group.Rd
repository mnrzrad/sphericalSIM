% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main_solver.R
\name{spherical_sim_group}
\alias{spherical_sim_group}
\title{Fit Spherical Single-Index Model with Group Lasso}
\usage{
spherical_sim_group(
  X,
  Y,
  group_idx,
  lambda,
  gamma,
  n_knots = 10,
  degree = 3,
  max_iter = 200,
  tol = 1e-06,
  beta_init = NULL,
  weights = NULL,
  verbose = TRUE
)
}
\arguments{
\item{X}{Design matrix (n × p)}

\item{Y}{Response matrix on unit sphere (n × q), where each row satisfies ||Y_i|| = 1}

\item{group_idx}{List of length G, where each element contains indices of predictors in that group}

\item{lambda}{Regularization parameter for group lasso penalty (controls sparsity)}

\item{gamma}{Regularization parameter for link function roughness (controls smoothness)}

\item{n_knots}{Number of internal B-spline knots for link function approximation (default 10)}

\item{degree}{Degree of B-spline basis functions (default 3 for cubic splines)}

\item{max_iter}{Maximum number of alternating optimization iterations (default 200)}

\item{tol}{Convergence tolerance for relative change in objective and β (default 1e-6)}

\item{beta_init}{Initial value for index parameter. If NULL, initialized randomly (default NULL)}

\item{weights}{Vector of group-specific weights (length G). If NULL, uses sqrt(group_size) (default NULL)}

\item{verbose}{Print progress messages every 10 iterations (default TRUE)}
}
\value{

}
\description{
Estimates a spherical single-index model with group-sparse index parameter
using alternating optimization with proximal gradient descent for β and
L-BFGS for the link function coefficients Θ.
}
\details{
\strong{Model:}
The spherical single-index model is:
\deqn{Y_i = m(X_i^T β) + ε_i}
where Y_i ∈ S^{q-1}, β ∈ R^p with ||β|| = 1, and m: R → S^{q-1} is an unknown smooth link function.

\strong{Objective Function:}
\deqn{Q(β, Θ) = \frac{1}{n}\sum_{i=1}^n ||Y_i - m(X_i^T β)||^2 + γ·\text{tr}(Θ^T Ω Θ) + λ\sum_{g=1}^G w_g ||β_g||_2}

Components:
\itemize{
  \item \strong{Prediction loss}: Mean squared error on the sphere
  \item \strong{Roughness penalty}: Controls smoothness of link function via penalty matrix Ω
  \item \strong{Group lasso penalty}: Induces group-level sparsity in β
}

\strong{Link Function Approximation:}
The link function is approximated using B-splines:
\enumerate{
  \item Compute single index: z_i = X_i^T β
  \item Represent link in R^{q-1}: u(z) = B(z)Θ where B(z) is the B-spline basis
  \item Map to sphere: m(z) = π^{-1}(u(z)) via inverse stereographic projection
}

\strong{Alternating Optimization Algorithm:}
\enumerate{
  \item \strong{Fix β, update Θ}: Solve smooth optimization problem using L-BFGS
        \deqn{\min_Θ L(β, Θ) + γ·\text{tr}(Θ^T Ω Θ)}
  \item \strong{Fix Θ, update β}: Use proximal gradient method with backtracking
        \itemize{
          \item Gradient step: β̃ = β - η∇_β L(β, Θ)
          \item Proximal step: β_tilde = prox_η λ P(β̃) (group-level soft-thresholding)
          \item Projection: β_new = β_tilde / ||β_tilde|| (enforce unit norm)
          \item Backtracking line search to ensure sufficient decrease
        }
  \item Iterate until convergence (relative change < tol in both objective and β)
}

\strong{Convergence Criteria:}
Algorithm stops when:
\itemize{
  \item Relative objective change < tol: |Q_t - Q_{t-1}| / |Q_{t-1}| < tol
  \item Parameter change < tol: ||β_t - β_{t-1}|| < tol
  \item Maximum iterations reached
}

\strong{Adaptive Weights:}
Adaptive group lasso uses data-driven weights w_g = ||β̂_g^{init}||^{-γ} to reduce
bias. These should be computed externally (e.g., via \code{\link{compute_adaptive_weights_fast}})
and passed through the weights argument.
}
\examples{
\dontrun{
# Generate synthetic data
set.seed(123)
data <- generate_spherical_data(n = 200, p = 30, G = 6,
                                active_groups = c(1, 3))

# Fit with standard weights
fit <- spherical_sim_group(
  X = data$X,
  Y = data$Y,
  group_idx = data$group_idx,
  lambda = 0.1,
  gamma = 0.05,
  n_knots = 8,
  verbose = TRUE
)

# Check selected groups
cat("Selected groups:", fit$selected_groups, "\n")
cat("True active groups:", data$active_groups, "\n")

# Plot convergence
plot(fit$objective, type = "l", log = "y",
     xlab = "Iteration", ylab = "Objective",
     main = "Convergence Path")

# Visualize group selection
barplot(fit$group_norms, names.arg = 1:length(fit$group_norms),
        xlab = "Group", ylab = "Group Norm",
        main = "Estimated Group Structure")
abline(h = 0, lty = 2)

# Fit with adaptive weights
adaptive_res <- compute_adaptive_weights_fast(
  data$X, data$Y, data$group_idx
)

fit_adaptive <- spherical_sim_group(
  X = data$X,
  Y = data$Y,
  group_idx = data$group_idx,
  lambda = 0.1,
  gamma = 0.05,
  weights = adaptive_res$weights,
  verbose = TRUE
)

# Compare selection
cat("Standard selected:", fit$selected_groups, "\n")
cat("Adaptive selected:", fit_adaptive$selected_groups, "\n")

# Visualize fitted link function
z_grid <- seq(min(fit$index), max(fit$index), length.out = 100)
z_clip <- pmax(pmin(z_grid, max(fit$knots) - 1e-6),
               min(fit$knots) + 1e-6)
B_grid <- splineDesign(fit$knots, z_clip, ord = fit$degree + 1)
U_grid <- B_grid \%*\% fit$Theta
m_grid <- inv_stereo(U_grid)

par(mfrow = c(1, 2))
plot(z_grid, m_grid[,1], type = "l", lwd = 2,
     xlab = "z = X^T β", ylab = "m_1(z)",
     main = "Link Function Component 1")
plot(z_grid, m_grid[,2], type = "l", lwd = 2,
     xlab = "z = X^T β", ylab = "m_2(z)",
     main = "Link Function Component 2")

# Compute prediction error
pred_error <- mean(rowSums((data$Y - fit$fitted)^2))
cat("Prediction error:", pred_error, "\n")

# Compare true vs estimated β (accounting for sign)
cor_pos <- cor(data$beta_true, fit$beta)
cor_neg <- cor(data$beta_true, -fit$beta)
cat("Correlation with true β:", max(abs(cor_pos), abs(cor_neg)), "\n")

# Plot true vs estimated coefficients
plot(data$beta_true, fit$beta, pch = 19,
     col = data$groups, asp = 1,
     xlab = "True β", ylab = "Estimated β",
     main = "Parameter Recovery")
abline(0, 1, col = "red", lty = 2)
abline(0, -1, col = "blue", lty = 2)
}

}
\references{
- Yuan, M., & Lin, Y. (2006). Model selection and estimation in regression
  with grouped variables. Journal of the Royal Statistical Society: Series B,
  68(1), 49-67.
- Eilers, P. H., & Marx, B. D. (1996). Flexible smoothing with B-splines and
  penalties. Statistical Science, 11(2), 89-121.
- Parikh, N., & Boyd, S. (2014). Proximal algorithms. Foundations and Trends
  in Optimization, 1(3), 127-239.
}
\seealso{
\code{\link{predict_spherical}} for prediction on new data,
\code{\link{cv_two_stage_adaptive}} for cross-validation,
\code{\link{compute_adaptive_weights_fast}} for adaptive weight computation,
\code{\link{prox_group_lasso}} for the proximal operator,
\code{\link{generate_spherical_data}} for data generation
}
