% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adaptive_weights.R
\name{compute_adaptive_weights_fast}
\alias{compute_adaptive_weights_fast}
\title{Compute Adaptive Weights via Fast Correlation Screening}
\usage{
compute_adaptive_weights_fast(
  X,
  Y,
  group_idx,
  gamma_power = 1,
  verbose = FALSE
)
}
\arguments{
\item{X}{Design matrix (n × p)}

\item{Y}{Response matrix on unit sphere (n × q)}

\item{group_idx}{List of length G, where each element contains indices of predictors in that group}

\item{gamma_power}{Power for adaptive weight formula (default 1). Higher values give stronger adaptation}

\item{verbose}{Print progress information (default FALSE)}
}
\value{
List with the following components:
\describe{
  \item{weights}{Vector of adaptive weights (length G). These should be passed
        to \code{\link{spherical_sim_group}} or \code{\link{cv_lambda_path_early_stop}}}
  \item{group_scores}{Vector of correlation scores for each group (length G).
        Shows s_g = max absolute correlation for group g}
  \item{method}{Character string: always "fast"}
}
}
\description{
Computes adaptive weights for the adaptive group lasso using a fast correlation-based
screening method. This approach avoids fitting an initial model, making it much
faster than \code{\link{compute_adaptive_weights_grouplasso}} while providing
reasonable weight estimates for variable selection.
}
\details{
This function provides a computationally efficient alternative to fitting an
initial group lasso model for computing adaptive weights.

\strong{Fast Weight Computation:}
\enumerate{
  \item \strong{Group scoring}: For each group g, compute
        \deqn{s_g = \max_{j \in G_g, k=1,...,q} |cor(X_j, Y_k)|}
        This captures the maximum absolute correlation between any predictor
        in group g and any response component
  \item \strong{Adaptive weights}: Compute
        \deqn{w_g^{(adapt)} = \frac{\sqrt{|G_g|}}{(s_g + \epsilon)^\gamma}}
        where ε = 0.01 prevents division by zero
  \item \strong{Normalize}: Scale weights so Σ_g w_g = G
}

\strong{Mathematical Rationale:}
The correlation score s_g serves as a proxy for the importance of group g:
\itemize{
  \item \emph{High s_g}: Strong marginal association → likely important → small weight
  \item \emph{Low s_g}: Weak marginal association → likely unimportant → large weight
}
This mimics the behavior of adaptive weights from an initial lasso fit, where
groups with large coefficients receive smaller penalties.

\strong{Comparison with Group Lasso Method:}
\tabular{lll}{
  \strong{Aspect} \tab \strong{Fast Method} \tab \strong{Group Lasso Method} \cr
  Speed \tab Very fast (O(npq)) \tab Slow (requires optimization) \cr
  Accuracy \tab Marginal associations \tab Joint model \cr
  Correlation handling \tab Poor with high correlation \tab Better with correlation \cr
  Use case \tab Large p, quick screening \tab Final analysis, moderate p \cr
  Recommended \tab p > 1000 or initial screening \tab p < 500, final model
}

\strong{When to Use Fast Method:}
\itemize{
  \item Very high-dimensional problems (p > 1000)
  \item Rapid exploratory analysis
  \item Initial screening before more careful analysis
  \item When computational resources are limited
  \item When initial group lasso fits are unstable
}

\strong{When to Use Group Lasso Method:}
\itemize{
  \item Final analysis requiring best possible selection
  \item Moderate dimensional problems (p < 500)
  \item When predictors are highly correlated
  \item When computational time is not critical
  \item Published results requiring highest accuracy
}

\strong{Limitations:}
\itemize{
  \item Uses marginal correlations, ignoring predictor relationships
  \item May give suboptimal weights when predictors are highly correlated
  \item Does not account for joint effects or confounding
  \item Fixed epsilon (0.01) may not be optimal for all problems
}
}
\examples{
\dontrun{
# Generate data
set.seed(123)
data <- generate_spherical_data(n = 200, p = 40, G = 8,
                                active_groups = c(1, 3, 5),
                                seed = 123)

# Compute adaptive weights (fast method)
adaptive_fast <- compute_adaptive_weights_fast(
  X = data$X,
  Y = data$Y,
  group_idx = data$group_idx,
  verbose = TRUE
)

# Examine results
cat("Fast adaptive weights:\n")
print(data.frame(
  Group = 1:length(adaptive_fast$weights),
  Weight = round(adaptive_fast$weights, 4),
  Score = round(adaptive_fast$group_scores, 4),
  TrueActive = 1:length(adaptive_fast$weights) \%in\% data$active_groups
))

# Visualize weights and scores
par(mfrow = c(1, 2))

# Correlation scores by group
barplot(adaptive_fast$group_scores, names.arg = 1:8,
        xlab = "Group", ylab = "Correlation Score",
        main = "Group Correlation Scores",
        col = ifelse(1:8 \%in\% data$active_groups, "lightblue", "lightgray"))
legend("topright", c("Active", "Inactive"),
       fill = c("lightblue", "lightgray"))

# Adaptive weights
barplot(adaptive_fast$weights, names.arg = 1:8,
        xlab = "Group", ylab = "Adaptive Weight",
        main = "Adaptive Weights (Fast)",
        col = ifelse(1:8 \%in\% data$active_groups, "lightblue", "lightgray"))

# Compare fast vs group lasso methods
adaptive_grouplasso <- compute_adaptive_weights_grouplasso(
  X = data$X,
  Y = data$Y,
  group_idx = data$group_idx,
  verbose = TRUE
)

# Plot comparison
plot(adaptive_grouplasso$weights, adaptive_fast$weights,
     pch = 19, cex = 1.5,
     xlab = "Group Lasso Weights",
     ylab = "Fast Weights",
     main = "Weight Comparison",
     col = ifelse(1:8 \%in\% data$active_groups, "blue", "red"))
abline(0, 1, col = "gray", lty = 2)
legend("topleft", c("Active", "Inactive"),
       col = c("blue", "red"), pch = 19)

# Correlation between weight methods
cor_weights <- cor(adaptive_grouplasso$weights, adaptive_fast$weights)
cat("\nCorrelation between weight methods:", round(cor_weights, 3), "\n")

# Timing comparison
system.time({
  weights_fast <- compute_adaptive_weights_fast(
    data$X, data$Y, data$group_idx
  )
})

system.time({
  weights_grouplasso <- compute_adaptive_weights_grouplasso(
    data$X, data$Y, data$group_idx
  )
})

# Use in cross-validation
cv_fast <- cv_two_stage_adaptive(
  X = data$X,
  Y = data$Y,
  group_idx = data$group_idx,
  use_adaptive = TRUE,
  adaptive_method = "fast",
  verbose = FALSE
)

cv_grouplasso <- cv_two_stage_adaptive(
  X = data$X,
  Y = data$Y,
  group_idx = data$group_idx,
  use_adaptive = TRUE,
  adaptive_method = "grouplasso",
  verbose = FALSE
)

# Compare selection performance
fit_fast <- spherical_sim_group(
  data$X, data$Y, data$group_idx,
  cv_fast$best_lambda, cv_fast$best_gamma,
  weights = adaptive_fast$weights, verbose = FALSE
)

fit_grouplasso <- spherical_sim_group(
  data$X, data$Y, data$group_idx,
  cv_grouplasso$best_lambda, cv_grouplasso$best_gamma,
  weights = adaptive_grouplasso$weights, verbose = FALSE
)

cat("\nFast method selected:", fit_fast$selected_groups, "\n")
cat("Group lasso method selected:", fit_grouplasso$selected_groups, "\n")
cat("True active groups:", data$active_groups, "\n")

# Compute selection metrics
TPR_fast <- length(intersect(fit_fast$selected_groups, data$active_groups)) /
            length(data$active_groups)
TPR_grouplasso <- length(intersect(fit_grouplasso$selected_groups, data$active_groups)) /
                  length(data$active_groups)

cat("\nTPR (fast):", TPR_fast, "\n")
cat("TPR (group lasso):", TPR_grouplasso, "\n")

# Effect of gamma_power
gamma_powers <- c(0.5, 1, 1.5, 2)

weights_list <- lapply(gamma_powers, function(gp) {
  res <- compute_adaptive_weights_fast(
    X = data$X, Y = data$Y, group_idx = data$group_idx,
    gamma_power = gp
  )
  res$weights
})

# Plot weights for different gamma_power
matplot(1:8, do.call(cbind, weights_list),
        type = "b", pch = 19, lty = 1,
        xlab = "Group", ylab = "Weight",
        main = "Fast Weights vs gamma_power")
legend("topright", paste("γ =", gamma_powers),
       col = 1:4, lty = 1, pch = 19)
abline(v = data$active_groups, col = "gray", lty = 2)

# High-dimensional example showing speed advantage
set.seed(456)
data_large <- generate_spherical_data(n = 500, p = 1000, G = 100,
                                      active_groups = 1:5,
                                      seed = 456)

cat("\nHigh-dimensional example (p = 1000, G = 100):\n")

time_fast <- system.time({
  weights_fast_large <- compute_adaptive_weights_fast(
    data_large$X, data_large$Y, data_large$group_idx
  )
})

cat("Fast method time:", time_fast["elapsed"], "seconds\n")
cat("(Group lasso method would take much longer)\n")

# Correlation between scores and true signals
true_active <- as.numeric(1:8 \%in\% data$active_groups)
cor_scores_truth <- cor(adaptive_fast$group_scores, true_active)
cat("\nCorrelation between correlation scores and true active groups:",
    round(cor_scores_truth, 3), "\n")

# Distribution of weights
active_weights <- adaptive_fast$weights[data$active_groups]
inactive_weights <- adaptive_fast$weights[setdiff(1:8, data$active_groups)]

boxplot(list(Active = active_weights, Inactive = inactive_weights),
        main = "Weight Distribution by Group Type",
        ylab = "Adaptive Weight",
        col = c("lightblue", "lightgray"))

cat("\nMean active group weight:", mean(active_weights), "\n")
cat("Mean inactive group weight:", mean(inactive_weights), "\n")
cat("Weight ratio (inactive/active):",
    mean(inactive_weights) / mean(active_weights), "\n")
}

}
\references{
- Fan, J., & Lv, J. (2008). Sure independence screening for ultrahigh
  dimensional feature space. Journal of the Royal Statistical Society:
  Series B, 70(5), 849-911.
- Zhao, P., & Yu, B. (2006). On model selection consistency of Lasso.
  Journal of Machine Learning Research, 7, 2541-2563.
- Zou, H. (2006). The adaptive lasso and its oracle properties. Journal of
  the American Statistical Association, 101(476), 1418-1429.
}
\seealso{
\code{\link{compute_adaptive_weights_grouplasso}} for more accurate but slower method,
\code{\link{cv_two_stage_adaptive}} for using adaptive weights in CV,
\code{\link{spherical_sim_group}} for model fitting with weights
}
