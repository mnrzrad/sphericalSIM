% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adaptive_weights.R
\name{compute_adaptive_weights_grouplasso}
\alias{compute_adaptive_weights_grouplasso}
\title{Compute Adaptive Weights via Initial Group Lasso}
\usage{
compute_adaptive_weights_grouplasso(
  X,
  Y,
  group_idx,
  gamma_power = 1,
  initial_lambda_fraction = 0.3,
  initial_gamma = 0.01,
  n_knots = 5,
  verbose = FALSE
)
}
\arguments{
\item{X}{Design matrix (n × p)}

\item{Y}{Response matrix on unit sphere (n × q)}

\item{group_idx}{List of length G, where each element contains indices of predictors in that group}

\item{gamma_power}{Power for adaptive weight formula (default 1). Higher values give stronger adaptation}

\item{initial_lambda_fraction}{Fraction of lambda_max for initial group lasso fit (default 0.3).
Should be large enough to get sparse solution but not so large that all groups are zeroed}

\item{initial_gamma}{Roughness penalty for initial fit (default 0.01). Usually set small}

\item{n_knots}{Number of internal B-spline knots for initial fit (default 5)}

\item{verbose}{Print progress information (default FALSE)}
}
\value{
List with the following components:
\describe{
  \item{weights}{Vector of adaptive weights (length G). These should be passed
        to \code{\link{spherical_sim_group}} or \code{\link{cv_lambda_path_early_stop}}}
  \item{beta_init}{Initial coefficient vector from group lasso fit (length p).
        NULL if initial fit failed}
  \item{group_norms_init}{Vector of group norms from initial fit (length G).
        Shows ||β̂_init_g|| for each group g}
  \item{n_selected_init}{Number of groups selected in initial fit (scalar)}
  \item{method}{Character string: "grouplasso" if successful, "standard" if fallback used}
}
}
\description{
Computes adaptive weights for the adaptive group lasso by fitting an initial
group lasso model and using the inverse of group coefficient norms. This approach
follows the adaptive lasso methodology and tends to give better variable selection
performance than standard group lasso.
}
\details{
The adaptive group lasso uses data-dependent weights to improve variable selection
properties. This function implements the two-stage procedure:

\strong{Adaptive Weight Computation:}
\enumerate{
  \item \strong{Compute lambda_max}: Determine the regularization strength that
        zeros out all groups using standard weights w_g^{(0)} = sqrt(|G_g|)
  \item \strong{Initial fit}: Fit group lasso with λ = initial_lambda_fraction × λ_max
        using standard weights to obtain β̂_init
  \item \strong{Compute group norms}: For each group g, calculate
        ||β̂_init_g||_2 = sqrt(Σ_{j∈G_g} β̂_init_j^2)
  \item \strong{Adaptive weights}: Compute
        \deqn{w_g^{(adapt)} = \frac{\sqrt{|G_g|}}{(||β̂_init_g||_2 + ε)^γ}}
        where ε = 10^{-4} prevents division by zero
  \item \strong{Normalize}: Scale weights so Σ_g w_g = G
}

\strong{Mathematical Formulation:}
The adaptive weights satisfy:
\deqn{w_g^{(adapt)} = w_g^{(0)} × (||β̂_init_g||_2 + ε)^{-γ} × \text{normalizer}}
where:
\itemize{
  \item w_g^{(0)} = sqrt(|G_g|) is the standard weight
  \item γ is the gamma_power parameter (typically 1)
  \item ε prevents numerical issues when ||β̂_init_g|| ≈ 0
  \item Normalizer ensures Σ_g w_g = G
}

\strong{Effect of Adaptive Weights:}
\itemize{
  \item \emph{Large ||β̂_init_g||}: Small weight w_g → less penalty → easier to select
  \item \emph{Small ||β̂_init_g||}: Large weight w_g → more penalty → harder to select
  \item Encourages consistent variable selection (oracle property)
  \item Reduces false positives compared to standard group lasso
}

\strong{Choosing initial_lambda_fraction:}
\itemize{
  \item Too small (< 0.1): Initial fit too dense, poor discrimination
  \item Too large (> 0.5): Initial fit too sparse, may miss important groups
  \item Recommended: 0.2-0.4 works well in practice
  \item Default 0.3 is a good balance for most problems
}

\strong{Choosing gamma_power:}
\itemize{
  \item γ = 1: Standard adaptive lasso (most common)
  \item γ > 1: Stronger adaptation, more aggressive penalty on weak groups
  \item γ < 1: Weaker adaptation, closer to standard group lasso
  \item Theory supports γ = 1 for oracle properties
}

\strong{Robustness:}
If the initial fit fails (convergence issues, numerical problems), the function
falls back to standard weights and issues a warning. This ensures the procedure
always returns valid weights.
}
\examples{
\dontrun{
# Generate data
set.seed(123)
data <- generate_spherical_data(n = 200, p = 40, G = 8,
                                active_groups = c(1, 3, 5),
                                seed = 123)

# Compute adaptive weights with defaults
adaptive_res <- compute_adaptive_weights_grouplasso(
  X = data$X,
  Y = data$Y,
  group_idx = data$group_idx,
  verbose = TRUE
)

# Examine weights
cat("Adaptive weights:\n")
print(data.frame(
  Group = 1:length(adaptive_res$weights),
  Weight = round(adaptive_res$weights, 4),
  InitNorm = round(adaptive_res$group_norms_init, 4),
  TrueActive = 1:length(adaptive_res$weights) \%in\% data$active_groups
))

# Visualize weights vs initial norms
par(mfrow = c(1, 2))

# Weights by group
barplot(adaptive_res$weights, names.arg = 1:8,
        xlab = "Group", ylab = "Adaptive Weight",
        main = "Adaptive Weights",
        col = ifelse(1:8 \%in\% data$active_groups, "lightblue", "lightgray"))
legend("topright", c("Active", "Inactive"),
       fill = c("lightblue", "lightgray"))

# Initial group norms
barplot(adaptive_res$group_norms_init, names.arg = 1:8,
        xlab = "Group", ylab = "||β_init||",
        main = "Initial Group Norms",
        col = ifelse(1:8 \%in\% data$active_groups, "lightblue", "lightgray"))

# Compare standard vs adaptive weights
standard_weights <- sapply(data$group_idx, function(idx) sqrt(length(idx)))

plot(standard_weights, adaptive_res$weights, pch = 19,
     xlab = "Standard Weight", ylab = "Adaptive Weight",
     main = "Standard vs Adaptive Weights")
abline(0, 1, col = "red", lty = 2)
text(standard_weights, adaptive_res$weights,
     labels = 1:8, pos = 3, cex = 0.8)

# Use adaptive weights in CV
cv_result <- cv_two_stage_adaptive(
  X = data$X,
  Y = data$Y,
  group_idx = data$group_idx,
  use_adaptive = TRUE,
  adaptive_method = "grouplasso",
  verbose = FALSE
)

# Fit model with adaptive weights
fit_adaptive <- spherical_sim_group(
  X = data$X,
  Y = data$Y,
  group_idx = data$group_idx,
  lambda = cv_result$best_lambda,
  gamma = cv_result$best_gamma,
  weights = adaptive_res$weights,
  verbose = FALSE
)

# Compare with standard group lasso
fit_standard <- spherical_sim_group(
  X = data$X,
  Y = data$Y,
  group_idx = data$group_idx,
  lambda = cv_result$best_lambda,
  gamma = cv_result$best_gamma,
  weights = standard_weights,
  verbose = FALSE
)

cat("\nStandard selected:", fit_standard$selected_groups, "\n")
cat("Adaptive selected:", fit_adaptive$selected_groups, "\n")
cat("True active:", data$active_groups, "\n")

# Effect of gamma_power
gamma_powers <- c(0.5, 1, 1.5, 2)

weights_list <- lapply(gamma_powers, function(gp) {
  res <- compute_adaptive_weights_grouplasso(
    X = data$X, Y = data$Y, group_idx = data$group_idx,
    gamma_power = gp, verbose = FALSE
  )
  res$weights
})

# Plot weights for different gamma_power
matplot(1:8, do.call(cbind, weights_list),
        type = "b", pch = 19, lty = 1,
        xlab = "Group", ylab = "Weight",
        main = "Weights vs gamma_power")
legend("topright", paste("γ =", gamma_powers),
       col = 1:4, lty = 1, pch = 19)
abline(v = data$active_groups, col = "gray", lty = 2)

# Effect of initial_lambda_fraction
lambda_fractions <- c(0.1, 0.2, 0.3, 0.5, 0.7)

n_selected_list <- sapply(lambda_fractions, function(frac) {
  res <- compute_adaptive_weights_grouplasso(
    X = data$X, Y = data$Y, group_idx = data$group_idx,
    initial_lambda_fraction = frac, verbose = FALSE
  )
  res$n_selected_init
})

plot(lambda_fractions, n_selected_list, type = "b", pch = 19,
     xlab = "initial_lambda_fraction",
     ylab = "Groups Selected in Initial Fit",
     main = "Initial Sparsity vs Lambda Fraction")
abline(h = length(data$active_groups), col = "red", lty = 2)

# Correlation between initial norms and true signals
true_active_indicator <- as.numeric(1:8 \%in\% data$active_groups)
cor_norms_truth <- cor(adaptive_res$group_norms_init, true_active_indicator)
cat("\nCorrelation between initial norms and true active groups:",
    round(cor_norms_truth, 3), "\n")

# Weight ratio: active vs inactive groups
active_weights <- adaptive_res$weights[data$active_groups]
inactive_weights <- adaptive_res$weights[setdiff(1:8, data$active_groups)]

cat("Mean active group weight:", mean(active_weights), "\n")
cat("Mean inactive group weight:", mean(inactive_weights), "\n")
cat("Ratio:", mean(inactive_weights) / mean(active_weights), "\n")

# Examine detailed initial fit
cat("\nInitial fit details:\n")
cat("Method:", adaptive_res$method, "\n")
cat("Groups selected:", adaptive_res$n_selected_init, "\n")
cat("Group norms range: [",
    min(adaptive_res$group_norms_init), ",",
    max(adaptive_res$group_norms_init), "]\n")
}

}
\references{
- Zou, H. (2006). The adaptive lasso and its oracle properties. Journal of
  the American Statistical Association, 101(476), 1418-1429.
- Huang, J., Ma, S., & Zhang, C. H. (2008). Adaptive Lasso for sparse
  high-dimensional regression models. Statistica Sinica, 18(4), 1603-1618.
- Wang, H., Li, B., & Leng, C. (2009). Shrinkage tuning parameter selection
  with a diverging number of parameters. Journal of the Royal Statistical
  Society: Series B, 71(3), 671-683.
}
\seealso{
\code{\link{compute_adaptive_weights_fast}} for faster alternative method,
\code{\link{cv_two_stage_adaptive}} for using adaptive weights in CV,
\code{\link{spherical_sim_group}} for model fitting with weights,
\code{\link{compute_lambda_max_with_weights}} for computing lambda_max
}
