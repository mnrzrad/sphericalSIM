% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main_solver.R
\name{eval_link}
\alias{eval_link}
\title{Evaluate Estimated Link Function}
\usage{
eval_link(fit, z_grid = NULL, n_grid = 100)
}
\arguments{
\item{fit}{Fitted model object returned by \code{\link{spherical_sim_group}}}

\item{z_grid}{Optional vector of single index values at which to evaluate the
link function. If NULL, a uniform grid of n_grid points is created spanning
the knot range (default NULL)}

\item{n_grid}{Number of grid points if z_grid is not provided (default 100)}
}
\value{
List with three components:
\describe{
  \item{z}{Vector of single index values where link is evaluated (length n_grid or length(z_grid))}
  \item{m}{Matrix of link function values in R^{q-1} (n_grid × (q-1))}
  \item{y_sphere}{Matrix of link function values on unit sphere S^{q-1} (n_grid × q).
        Each row satisfies ||y_sphere[i,]|| = 1}
}
}
\description{
Evaluates the estimated link function m̂(z) from a fitted spherical single-index
model on a specified grid or default sequence of single index values.
}
\details{
The link function m: R → S^{q-1} maps single index values to the unit sphere.
It is estimated using B-spline approximation in R^{q-1} followed by inverse
stereographic projection.

\strong{Evaluation Process:}
\enumerate{
  \item Create or validate z_grid (clipped to valid knot range)
  \item Evaluate B-spline basis: B(z_grid)
  \item Compute link in R^{q-1}: m̂(z) = B(z) Θ̂
  \item Map to sphere: ŷ(z) = π^{-1}(m̂(z))
}

\strong{Return Values:}
The function returns both:
\itemize{
  \item The link function in R^{q-1} space (m)
  \item The link function on the sphere S^{q-1} (y_sphere)
}
The R^{q-1} representation is useful for visualization and understanding the
link structure before projection, while the spherical representation shows
the actual predicted curve on the sphere.

\strong{Valid Evaluation Range:}
The link function should only be evaluated within the range of observed single
index values from training. The function automatically clips z_grid to the
valid knot range [min(knots) + ε, max(knots) - ε].
}
\examples{
\dontrun{
# Fit model to generated data
set.seed(123)
data <- generate_spherical_data(n = 200, p = 20, seed = 123)

fit <- spherical_sim_group(
  X = data$X,
  Y = data$Y,
  group_idx = data$group_idx,
  lambda = 0.1,
  gamma = 0.1,
  n_knots = 5,
  verbose = FALSE
)

# Evaluate link on default grid
link_eval <- eval_link(fit)

# Verify points are on unit sphere
all(abs(rowSums(link_eval$y_sphere^2) - 1) < 1e-10)  # TRUE

# Plot estimated link function (first component)
plot(link_eval$z, link_eval$m[,1], type = "l", lwd = 2,
     xlab = "Single Index z", ylab = "m̂₁(z)",
     main = "Estimated Link Function (Component 1)")

# Add true link if known
z_true <- link_eval$z
m_true <- cbind(sin(z_true), 0.5 * cos(z_true))
lines(z_true, m_true[,1], col = "blue", lty = 2, lwd = 2)
legend("topright", c("Estimated", "True"),
       col = c("black", "blue"), lty = 1:2, lwd = 2)

# Plot both components
par(mfrow = c(1, 2))
plot(link_eval$z, link_eval$m[,1], type = "l", lwd = 2,
     xlab = "z", ylab = "m̂₁(z)", main = "Component 1")
lines(z_true, m_true[,1], col = "blue", lty = 2, lwd = 2)

plot(link_eval$z, link_eval$m[,2], type = "l", lwd = 2,
     xlab = "z", ylab = "m̂₂(z)", main = "Component 2")
lines(z_true, m_true[,2], col = "blue", lty = 2, lwd = 2)

# Visualize link as curve on sphere (3D)
# First two dimensions
plot(link_eval$y_sphere[,1], link_eval$y_sphere[,2],
     type = "l", lwd = 2, asp = 1,
     xlab = "y₁", ylab = "y₂",
     main = "Link Function on Sphere (2D projection)")

# Add unit circle for reference
theta <- seq(0, 2*pi, length.out = 100)
lines(cos(theta), sin(theta), col = "gray", lty = 2)

# Color by z value
cols <- rainbow(nrow(link_eval$y_sphere))
plot(link_eval$y_sphere[,1], link_eval$y_sphere[,2],
     col = cols, pch = 19, cex = 0.5, asp = 1,
     xlab = "y₁", ylab = "y₂",
     main = "Link Colored by Single Index")

# Evaluate at specific points
z_specific <- seq(-2, 2, by = 0.5)
link_specific <- eval_link(fit, z_grid = z_specific)

print(data.frame(
  z = link_specific$z,
  m1 = link_specific$m[,1],
  m2 = link_specific$m[,2]
))

# Compare with training data
plot(link_eval$z, link_eval$m[,1], type = "l", lwd = 2,
     xlab = "Single Index", ylab = "Response Component 1",
     main = "Link Function vs Training Data")
points(fit$index, data$Y[,1], pch = 19, cex = 0.5, col = "red")
legend("topright", c("Estimated Link", "Training Data"),
       col = c("black", "red"), lty = c(1, NA), pch = c(NA, 19))

# Compute smoothness of estimated link
m_diff <- diff(link_eval$m[,1])
z_diff <- diff(link_eval$z)
derivatives <- m_diff / z_diff

plot(link_eval$z[-1], derivatives, type = "l", lwd = 2,
     xlab = "z", ylab = "dm̂₁/dz",
     main = "Estimated Link Derivative")
}

}
\seealso{
\code{\link{spherical_sim_group}} for model fitting,
\code{\link{predict_spherical}} for predictions on new data,
\code{\link{inv_stereo}} for inverse stereographic projection
}
