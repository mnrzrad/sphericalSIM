% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulation.R
\name{run_single_simulation}
\alias{run_single_simulation}
\title{Run Single Simulation for Spherical Single-Index Model with Group Lasso}
\usage{
run_single_simulation(
  sim_id,
  n = 500,
  p = 100,
  q = 3,
  G = 10,
  active_groups = c(1, 3, 5),
  kappa = 50,
  rho = 0.5,
  use_adaptive = TRUE,
  adaptive_method = "fast",
  nlambda = 12,
  ngamma_coarse = 5,
  ngamma_fine = 8,
  n_folds = 3,
  n_knots = 5,
  verbose = FALSE,
  seed_offset = 10000
)
}
\arguments{
\item{sim_id}{Simulation ID number for tracking and seed generation}

\item{n}{Sample size (default 500)}

\item{p}{Total number of predictors (default 100)}

\item{q}{Response dimension on sphere (default 3, i.e., unit sphere in R^3)}

\item{G}{Total number of groups (default 10)}

\item{active_groups}{Vector of true active group indices (default c(1, 3, 5))}

\item{kappa}{Concentration parameter for von Mises-Fisher distribution (default 50)}

\item{rho}{Within-group correlation for predictor generation (default 0.5)}

\item{use_adaptive}{Use adaptive group lasso weights (default TRUE)}

\item{adaptive_method}{Method for computing adaptive weights: "fast" or "grouplasso" (default "fast")}

\item{nlambda}{Number of lambda values in CV grid (default 12)}

\item{ngamma_coarse}{Number of gamma values in coarse CV stage (default 5)}

\item{ngamma_fine}{Number of gamma values in fine CV stage (default 8)}

\item{n_folds}{Number of cross-validation folds (default 3)}

\item{n_knots}{Number of internal B-spline knots for link function approximation (default 5)}

\item{verbose}{Print detailed progress messages (default FALSE)}

\item{seed_offset}{Base seed offset for reproducibility; actual seed is seed_offset + sim_id (default 10000)}
}
\value{
A list containing:
\describe{
  \item{sim_id}{Simulation identifier}
  \item{beta_true}{True index parameter vector (length p)}
  \item{m_true}{True link function evaluated on grid (n_grid × q matrix)}
  \item{z_grid}{Grid points where link function is evaluated}
  \item{true_active_groups}{True active group indices}
  \item{beta_est}{Estimated index parameter vector (length p)}
  \item{m_est}{Estimated link function on grid (n_grid × q matrix)}
  \item{selected_groups}{Selected group indices from final model}
  \item{best_lambda}{Optimal lambda from cross-validation}
  \item{best_gamma}{Optimal gamma from cross-validation}
  \item{weights}{Adaptive weights used in final model}
  \item{n_selected}{Number of groups selected}
  \item{TPR}{True positive rate: proportion of true active groups selected}
  \item{FPR}{False positive rate: proportion of inactive groups incorrectly selected}
  \item{beta_l2_error}{L2 error for beta (accounting for sign ambiguity)}
  \item{angular_error}{Angular error between true and estimated beta (in degrees)}
  \item{link_mse}{Mean squared error of link function estimation}
  \item{pred_error}{Prediction error on training data}
  \item{converged}{Logical indicating convergence (TRUE if n_iter < 200)}
  \item{n_iter}{Number of iterations until convergence}
}
}
\description{
Performs a complete simulation run including data generation, cross-validation
for tuning parameter selection, final model fitting, and comprehensive evaluation
of variable selection and estimation performance.
}
\details{
The function executes a complete simulation pipeline:
\enumerate{
  \item \strong{Data Generation}: Generates synthetic data from a spherical single-index
        model with specified parameters using \code{\link{generate_spherical_data}}
  \item \strong{Cross-Validation}: Performs two-stage cross-validation with adaptive
        weights to select optimal lambda and gamma parameters
  \item \strong{Final Fitting}: Fits the final model with selected tuning parameters
        using \code{\link{spherical_sim_group}}
  \item \strong{Link Evaluation}: Estimates the link function on a grid of 100 points
  \item \strong{Performance Metrics}: Computes comprehensive evaluation metrics including
        variable selection accuracy and estimation errors
}

The true link function used is m(z) = [sin(z), 0.5*cos(z)]^T, which is evaluated
on the same grid as the estimated link for fair comparison.

\strong{Evaluation Metrics:}
\itemize{
  \item \emph{Variable Selection}: TPR (true positive rate), FPR (false positive rate)
  \item \emph{Parameter Estimation}: L2 error (with sign correction), angular error
  \item \emph{Function Estimation}: Link MSE, prediction error
  \item \emph{Convergence}: Number of iterations, convergence status
}

\strong{Sign Ambiguity:} Since the spherical single-index model has identification
up to sign (beta and -beta give the same model), the L2 error is computed as
min(||beta_est - beta_true||, ||beta_est + beta_true||).
}
\examples{
\dontrun{
# Run single simulation with default settings
result <- run_single_simulation(sim_id = 1)

# Check variable selection performance
cat("Selected groups:", result$selected_groups, "\n")
cat("True active groups:", result$true_active_groups, "\n")
cat("TPR:", result$TPR, "FPR:", result$FPR, "\n")

# Examine estimation accuracy
cat("Angular error:", result$angular_error, "degrees\n")
cat("Link MSE:", result$link_mse, "\n")

# Plot true vs estimated link function
plot(result$z_grid, result$m_true[,1], type = "l", col = "blue",
     xlab = "z", ylab = "m_1(z)", main = "Link Function Component 1")
lines(result$z_grid, result$m_est[,1], col = "red", lty = 2)
legend("topright", c("True", "Estimated"), col = c("blue", "red"), lty = 1:2)

# Run with custom settings and verbose output
result <- run_single_simulation(
  sim_id = 1,
  n = 200,
  p = 50,
  G = 5,
  active_groups = c(1, 2),
  use_adaptive = TRUE,
  adaptive_method = "grouplasso",
  verbose = TRUE
)

# Multiple simulations for Monte Carlo study
results <- lapply(1:100, function(i) {
  run_single_simulation(sim_id = i, verbose = FALSE)
})

# Summarize performance across simulations
mean_tpr <- mean(sapply(results, function(x) x$TPR))
mean_angular <- mean(sapply(results, function(x) x$angular_error))
cat("Average TPR:", mean_tpr, "\n")
cat("Average angular error:", mean_angular, "degrees\n")
}

}
\seealso{
\code{\link{generate_spherical_data}} for data generation,
\code{\link{cv_two_stage_adaptive}} for cross-validation,
\code{\link{spherical_sim_group}} for model fitting,
\code{\link{run_simulation_study}} for running multiple simulations,
\code{\link{summarize_results}} for analyzing simulation results
}
